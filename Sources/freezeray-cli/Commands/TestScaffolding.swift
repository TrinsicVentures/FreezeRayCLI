import Foundation

/// Helper struct for test scaffolding operations
/// Extracted from FreezeCommand to enable unit testing
public struct TestScaffolding {

    public init() {}

    /// Result of scaffolding operation
    public struct ScaffoldResult {
        public let fileName: String
        public let created: Bool  // true if created, false if already existed
        public let createdFile: URL?  // URL if file was created
        public let targetPath: URL?   // Target path (whether created or skipped)
        public let skipped: Bool      // true if file existed and was not overwritten

        public init(fileName: String, created: Bool, createdFile: URL? = nil, targetPath: URL? = nil, skipped: Bool = false) {
            self.fileName = fileName
            self.created = created
            self.createdFile = createdFile
            self.targetPath = targetPath
            self.skipped = skipped
        }
    }

    /// Scaffolds a drift test file for a schema version
    /// Only creates the file if it doesn't already exist (user-owned), unless force is true
    public func scaffoldDriftTest(
        testsDir: URL,
        schemaType: String,
        appTarget: String,
        version: String,
        force: Bool = false
    ) throws -> ScaffoldResult {
        let versionSafe = version.replacingOccurrences(of: ".", with: "_")
        let fileName = "\(schemaType)_DriftTests.swift"
        let filePath = testsDir.appendingPathComponent(fileName)

        // Skip if file already exists (user-owned, never overwrite) unless force is true
        if FileManager.default.fileExists(atPath: filePath.path) && !force {
            return ScaffoldResult(fileName: fileName, created: false, createdFile: nil, targetPath: filePath, skipped: true)
        }

        let testContent = """
        // AUTO-GENERATED by FreezeRay CLI
        // This file is scaffolded once and owned by you. Customize as needed.
        //
        // Purpose: Verify that the frozen schema v\(version) hasn't drifted
        // Generated by: freezeray freeze \(version)

        import Testing
        import FreezeRay
        @testable import \(appTarget)

        /// Drift test for \(schemaType) v\(version)
        ///
        /// This test verifies that the current schema definition matches the frozen fixture.
        /// If this test fails, it means the schema has been modified since it was frozen.
        ///
        /// Note: Tests run serially to avoid SwiftData store conflicts
        @Suite(.serialized)
        struct \(schemaType)_\(versionSafe)_DriftTests {
            @Test("\(schemaType) v\(version) has not drifted")
            func test\(schemaType)_\(versionSafe)_Drift() throws {
                // Call the macro-generated check function
                try \(schemaType).__freezeray_check_\(versionSafe)()

                // TODO: Add custom data validation here
                // Example:
                // - Verify specific model properties exist
                // - Check relationship configurations
                // - Validate index definitions
            }
        }

        """

        try testContent.write(to: filePath, atomically: true, encoding: .utf8)

        return ScaffoldResult(fileName: fileName, created: true, createdFile: filePath, targetPath: filePath, skipped: false)
    }

    /// Scaffolds a migration test file for upgrading from one version to another
    /// Only creates the file if it doesn't already exist (user-owned), unless force is true
    public func scaffoldMigrationTest(
        testsDir: URL,
        migrationPlan: String,
        fromVersion: String,
        fromSchemaType: String,
        toVersion: String,
        toSchemaType: String,
        appTarget: String,
        force: Bool = false
    ) throws -> ScaffoldResult {
        let fromSafe = fromVersion.replacingOccurrences(of: ".", with: "_")
        let toSafe = toVersion.replacingOccurrences(of: ".", with: "_")
        let fileName = "MigrateV\(fromSafe)toV\(toSafe)_Tests.swift"
        let filePath = testsDir.appendingPathComponent(fileName)

        // Skip if file already exists (user-owned, never overwrite) unless force is true
        if FileManager.default.fileExists(atPath: filePath.path) && !force {
            return ScaffoldResult(fileName: fileName, created: false, createdFile: nil, targetPath: filePath, skipped: true)
        }

        let testContent = """
        // AUTO-GENERATED by FreezeRay CLI
        // This file is scaffolded once and owned by you. Customize as needed.
        //
        // Purpose: Test migration from v\(fromVersion) → v\(toVersion)
        // Generated by: freezeray freeze \(toVersion)

        import Testing
        import FreezeRay
        @testable import \(appTarget)

        /// Migration test from v\(fromVersion) → v\(toVersion)
        ///
        /// This test verifies that the migration path between these versions works correctly.
        ///
        /// Note: Tests run serially to avoid SwiftData store conflicts
        @Suite(.serialized)
        struct MigrateV\(fromSafe)toV\(toSafe)_Tests {
            @Test("Migrate v\(fromVersion) → v\(toVersion)")
            func testMigrateV\(fromSafe)toV\(toSafe)() throws {
                // Test the migration using FreezeRayRuntime
                try FreezeRayRuntime.testMigration(
                    from: \(fromSchemaType).self,
                    to: \(toSchemaType).self,
                    migrationPlan: \(migrationPlan).self
                )

                // TODO: Add data integrity checks here
                // Example:
                // - Verify data is preserved during migration
                // - Check that new fields have default values
                // - Validate relationship updates
                // - Ensure no data loss for critical fields
            }
        }

        """

        try testContent.write(to: filePath, atomically: true, encoding: .utf8)

        return ScaffoldResult(fileName: fileName, created: true, createdFile: filePath, targetPath: filePath, skipped: false)
    }

    /// Finds the previous version by scanning the Fixtures directory
    /// Returns nil if no previous version exists (this is the first schema)
    public func findPreviousVersion(current: String, fixturesDir: URL) -> String? {
        guard FileManager.default.fileExists(atPath: fixturesDir.path) else {
            return nil
        }

        guard let contents = try? FileManager.default.contentsOfDirectory(atPath: fixturesDir.path) else {
            return nil
        }

        // Filter out non-version directories and the current version
        let versions = contents.filter { dir in
            dir != current && dir.range(of: #"^\d+\.\d+\.\d+$"#, options: .regularExpression) != nil
        }

        guard !versions.isEmpty else {
            return nil
        }

        // Sort semantically (semantic versioning)
        let sorted = versions.sorted { v1, v2 in
            let c1 = v1.split(separator: ".").compactMap { Int($0) }
            let c2 = v2.split(separator: ".").compactMap { Int($0) }

            for i in 0..<min(c1.count, c2.count) {
                if c1[i] != c2[i] {
                    return c1[i] < c2[i]
                }
            }
            return c1.count < c2.count
        }

        // Return the highest version that's less than current
        let currentComponents = current.split(separator: ".").compactMap { Int($0) }
        for version in sorted.reversed() {
            let versionComponents = version.split(separator: ".").compactMap { Int($0) }

            var isLess = false
            for i in 0..<min(currentComponents.count, versionComponents.count) {
                if versionComponents[i] < currentComponents[i] {
                    isLess = true
                    break
                } else if versionComponents[i] > currentComponents[i] {
                    break
                }
            }

            if isLess {
                return version
            }
        }

        return nil
    }
}
